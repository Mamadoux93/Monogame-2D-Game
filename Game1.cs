// `Data` contains the CSVs for the project
// `Sprite.cs` is the Sprite class referenced in this file
// A good portion of this code is automatically generated by the
// MonoGame template; don't be deterred!

using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using UltraLongMonogameTutoriel.Managers;
using UltraLongMonogameTutoriel.NPS;
using UltraLongMonogameTutoriel.Scenes;
using static System.Formats.Asn1.AsnWriter;

namespace UltraLongMonogameTutoriel;

public class Game1 : Game
{
    private GraphicsDeviceManager _graphics;
    private SpriteBatch _spriteBatch;
    private GameWindow _window;


    private readonly Dictionary<Vector2, int> zazamg;
    private readonly Dictionary<Vector2, int> zazafg;
    private readonly Dictionary<Vector2, int> zazacollisions;
    private readonly Dictionary<Vector2 , int> level2collisions;
    private readonly Dictionary<Vector2, int> level2mg;
    private readonly Dictionary<Vector2, int> level2fg;
    private readonly Dictionary<Vector2, int> level2newfg;
    private readonly Dictionary<Vector2, int> level2newmg;


    private int spawnPointX  /*1001*/;
    private int spawnPointY /*8256*/;



    private Texture2D rectangleTexture;
    private Texture2D pixel;

    private Texture2D textureAtlas;
    private Texture2D collisionTexture;
    private Texture2D newTexture;

    private List<Sprite> sprites;
    private List<Sprite> usableItems;
    private List<Sprite> binList;


    private TriggerManager triggerManager;
    private CameraManager cameraManager;
    private GameManager gameManager;
    private SceneManager sceneManager;


    int num_tiles_per_row = 8;
    int pixel_tilesize = 8;

    private SpriteFont font;

    private KeyboardState prevKeystate;

    // sprite

    private Player player;
    private EnemyZebi enemy;
    private Items mushroom;
    private Projectiles projectile;

    private IScene[] scenes;


    private Dictionary<EnemyZebi, TriggerBox> enemyBoxes = new();
    private List<Rectangle> intersections;

    public Game1()
    {
        _graphics = new GraphicsDeviceManager(this);
        _window = this.Window;
        _window.AllowUserResizing = true;
        Content.RootDirectory = "Content";
        IsMouseVisible = true;

        zazafg = LoadMap("../../../Data/zaza_fg.csv");
        zazamg = LoadMap("../../../Data/zaza_mg.csv");
        zazacollisions = LoadMap("../../../Data/zaza_collisions.csv");
        level2fg = LoadMap("../../../Data/Level2_fg.csv");
        level2mg = LoadMap("../../../Data/Level2_mg.csv");
        level2collisions = LoadMap("../../../Data/Level2_collisions.csv");
        level2newfg = LoadMap("../../../Data/Level2_newfg.csv");
        level2newmg = LoadMap("../../../Data/Level2_newmg.csv");
        





        intersections = new();
        sprites = new List<Sprite>();
        usableItems = new List<Sprite>();
        binList = new List<Sprite>();
        enemyBoxes = new Dictionary<EnemyZebi, TriggerBox>();

        sceneManager = new();
    }

    // Opens a CSV file, reads it line by line, splits the line into
    // an array of integers. Converts data into a Dictionary where the
    // keys is the physical position of the number in the file
    // (e.g. line 3, column 2) => (2, 1)).
    private Dictionary<Vector2, int> LoadMap(string filepath)
    {
        Dictionary<Vector2, int> result = new();

        StreamReader reader = new(filepath);

        int y = 0;
        string line;
        while ((line = reader.ReadLine()) != null)
        {

            string[] items = line.Split(',');

            for (int x = 0; x < items.Length; x++)
            {
                if (int.TryParse(items[x], out int value))
                {
                    if (value > -1)
                    {
                        result[new Vector2(x, y)] = value;
                    }
                }
            }
            y++;

        }

        return result;
    }

    protected override void Initialize()
    {
        // TODO: Add your initialization logic here
        
        var screenWidth = GraphicsAdapter.DefaultAdapter.CurrentDisplayMode.Width;
        var screenHeight = GraphicsAdapter.DefaultAdapter.CurrentDisplayMode.Height;

        _graphics.PreferredBackBufferWidth = screenWidth;
        _graphics.PreferredBackBufferHeight = screenHeight;
        _graphics.SynchronizeWithVerticalRetrace = false;
        this.IsFixedTimeStep = true;
        _graphics.IsFullScreen = true;
        _graphics.ApplyChanges();

        Globals.Content = Content;
        base.Initialize();
    }

    protected override void LoadContent()
    {
        _spriteBatch = new SpriteBatch(GraphicsDevice);

        Globals.SpriteBatch = _spriteBatch;
        Globals.GraphicsDevice = GraphicsDevice;

        RessourceManager resourceManager = new();
        resourceManager.LoadContent(Content);



        sceneManager.AddScene(new SpaceScene(Content, sceneManager, _graphics));

        RessourceManager.Textures["rectangleTexture"] = rectangleTexture;

        scenes = new IScene[]
        {
            new SpaceScene(Content, sceneManager, _graphics),
            new GameStartScene(Content, sceneManager, _graphics)
        };

        cameraManager = new(1437, -1000, _graphics);

        triggerManager = new(cameraManager);
        
        textureAtlas = Content.Load<Texture2D>("tempassets");
        collisionTexture = Content.Load<Texture2D>("hitboxes");
        newTexture = Content.Load<Texture2D>("atlas");


        pixel = new Texture2D(GraphicsDevice, 1, 1);
        pixel.SetData(new[] { Color.White });

        font = Content.Load<SpriteFont>("font");

        player = new Player(RessourceManager.Textures["player_static"], new Rectangle(451, 8320, Globals.TILESIZE, Globals.TILESIZE), new Rectangle(0, 0, 8, 16), cameraManager);
        enemy = new EnemyZebi(RessourceManager.Textures["player_static"], new Rectangle(0, 0, Globals.TILESIZE, Globals.TILESIZE * 2), new Rectangle(0, 0, 8, 16));
        mushroom = new Items(RessourceManager.Textures["Mushroom"], new Rectangle(0, 0, Globals.TILESIZE, Globals.TILESIZE), new Rectangle(0, 0, 8, 8));
        projectile = new Projectiles(RessourceManager.Textures["player_static"], new Rectangle(0, 0, Globals.TILESIZE, Globals.TILESIZE));

        this.gameManager = new GameManager(new GameManagerConfig
        {
            Player = player,
            CameraManager = cameraManager,
            RessourceManager = resourceManager,
            UsableItems = usableItems,
            SceneManager = sceneManager,
            _GraphicsDeviceManager = _graphics
        });

        
        Globals.Player = player;
        Globals.UsableItems = usableItems;


        sprites.Add(player);
    }

    protected override void Update(GameTime gameTime)
    {
        if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape))
            Exit();

        sceneManager.GetCurrentScene().Update(gameTime);

        player.Update(Keyboard.GetState(), prevKeystate, gameTime);

        prevKeystate = Keyboard.GetState();

        player.Walled = false;

        foreach (var scene in scenes)
        {
            //Debug.WriteLine(scene);
            if (sceneManager.CurrentScene.GetType() == scene.GetType())
            {
                if (Globals.LevelChange)
                {
                    player.Respawn(scene.SpawnPointX, scene.SpawnPointY);
                    Globals.LevelChange = false;
                }
                player.HealthMethod(scene.SpawnPointX, scene.SpawnPointY);

                HorizontalCollisions(gameTime, scene.Collisions, scene.Fg);

                VerticalCollisions(scene.Collisions, scene.Fg, scene.Mg);
            }
        }
        

        StompMecanism(gameTime);

        ListManager();

        if (Keyboard.GetState().IsKeyDown(Keys.I))
        {
            for (int i = 0; i < Math.Pow(11, 6); i++)
            {
                i++;
                i--;
            }
        }

        sprites.RemoveAll(sprite => binList.Contains(sprite));
        binList.Clear();

        
        Debug.WriteLineIf(sprites.OfType<EnemyZebi>().Any() || sprites.OfType<Projectiles>().Any(), $"Nombre d'ennemis: {sprites.OfType<EnemyZebi>().Count()} | Nombre de projectiles: {sprites.OfType<Projectiles>().Count()}");

        if (!cameraManager.IsCinemating && !cameraManager.FirstCinematic)
        {
            int levelWidth = 657 * Globals.TILESIZE;
            int levelHeight = 135 * Globals.TILESIZE;

            cameraManager.CameraPostion = new Vector2(
                -player.rect.X + (_graphics.PreferredBackBufferWidth / 2) - (player.rect.Width / 2),
                -player.rect.Y + (_graphics.PreferredBackBufferHeight / 2) - (player.rect.Height / 2)
    );
            //Camera à la Mario
            /*cameraManager.CameraPostion = new Vector2(
                MathHelper.Clamp(-player.rect.X + (_graphics.PreferredBackBufferWidth / 2) - (player.rect.Width / 2), -levelWidth + _graphics.PreferredBackBufferWidth, 0),
                MathHelper.Clamp(-player.rect.Y + (_graphics.PreferredBackBufferHeight / 2) - (player.rect.Height / 2), -levelHeight + _graphics.PreferredBackBufferHeight, 0)
    );*/

        }
        //Debug.WriteLine($"position: {player.rect.X} - {player.rect.Y} - {cameraManager.CameraPostion.X} - {cameraManager.CameraPostion.Y}");
        sprites.RemoveAll(s => binList.Contains(s));

        Globals.Update(gameTime);
        cameraManager.Update(gameTime);
        gameManager.Update();
        base.Update(gameTime);
    }

    // grabs the intersecting tiles for a Rect. This grabs all tile positions where
    // an intersection is __possible__, not if a tile actually exists there.
    public List<Rectangle> getIntersectingTilesHorizontal(Rectangle target)
    {

        List<Rectangle> intersections = new();

        int widthInTiles = (target.Width - (target.Width % Globals.TILESIZE)) / Globals.TILESIZE;
        int heightInTiles = (target.Height - (target.Height % Globals.TILESIZE)) / Globals.TILESIZE;

        for (int x = 0; x <= widthInTiles; x++)
        {
            for (int y = 0; y <= heightInTiles; y++)
            {

                intersections.Add(new Rectangle(

                    (target.X + x * Globals.TILESIZE) / Globals.TILESIZE,
                    (target.Y + y * (Globals.TILESIZE - 1)) / Globals.TILESIZE,
                    Globals.TILESIZE,
                    Globals.TILESIZE

                ));

            }
        }

        return intersections;
    }
    public List<Rectangle> getIntersectingTilesVertical(Rectangle target)
    {

        List<Rectangle> intersections = new();

        int widthInTiles = (target.Width - (target.Width % Globals.TILESIZE)) / Globals.TILESIZE;
        int heightInTiles = (target.Height - (target.Height % Globals.TILESIZE)) / Globals.TILESIZE;

        for (int x = 0; x <= widthInTiles; x++)
        {
            for (int y = 0; y <= heightInTiles; y++)
            {

                intersections.Add(new Rectangle(

                    (target.X + x * (Globals.TILESIZE)) / Globals.TILESIZE,
                    (target.Y + y * Globals.TILESIZE) / Globals.TILESIZE,
                    Globals.TILESIZE,
                    Globals.TILESIZE

                ));

            }
        }

        return intersections;
    }

    protected override void Draw(GameTime gameTime)
    {      

        float deltaTime = (float)gameTime.ElapsedGameTime.TotalSeconds; // Obliger d'utiliser cette variable locale car Globals.DeltaTime reste bloqué à la valeur précedente dans Draw()


        GraphicsDevice.Clear(Color.CornflowerBlue);

        // TODO: Add your drawing code here
        _spriteBatch.Begin(samplerState: SamplerState.PointClamp);

        sceneManager.GetCurrentScene().Draw();

        float drawDistance =(float)(_graphics.PreferredBackBufferWidth / 1.5);

        foreach (var scene in scenes)
        {
            if(sceneManager.GetCurrentScene().GetType() == scene.GetType())
            {
                MapDraw(drawDistance, scene.Fg, textureAtlas);
                MapDraw(drawDistance, scene.Mg, textureAtlas);
                MapDraw(drawDistance, scene.NewFg, newTexture);
                MapDraw(drawDistance, scene.NewMg, newTexture);
                if (Keyboard.GetState().IsKeyDown(Keys.B))
                {
                    MapDraw(drawDistance, scene.Collisions, collisionTexture);
                }
            }
        }

        SpritesDraw(drawDistance);

        Globals.SpriteBatch.Draw(pixel, new Rectangle(0, 0, 1200, 50), Color.Red * 0.5f);

        Globals.SpriteBatch.DrawString(font, $"FPS:{Math.Round( 1 / deltaTime)}  Position:{player.rect}  Level:{sceneManager.GetCurrentScene().GetType().Name}", new Vector2(0, 5), Color.White);

       /* Globals.SpriteBatch.DrawString(font, $"{player.rect}", new Vector2(200, 5), Color.White);

        Globals.SpriteBatch.DrawString(font, $"Level:{sceneManager.GetCurrentScene().GetType().Name}", new Vector2(800, 5), Color.White);*/

        gameManager.Draw();

        _spriteBatch.End();

        base.Draw(gameTime);
    }


    public void DrawRectHollow(SpriteBatch spriteBatch, Rectangle rect, Color color, int thickness)
    {
        spriteBatch.Draw(pixel, new Rectangle(rect.X + (int)cameraManager.CameraPostion.X, rect.Y + (int)cameraManager.CameraPostion.Y, rect.Width, thickness), color);
        spriteBatch.Draw(pixel, new Rectangle(rect.X + (int)cameraManager.CameraPostion.X, rect.Y + (int)cameraManager.CameraPostion.Y, thickness, rect.Height), color);
        spriteBatch.Draw(pixel, new Rectangle(rect.X + (int)cameraManager.CameraPostion.X, rect.Y + rect.Height + (int)cameraManager.CameraPostion.Y - thickness, rect.Width, thickness), color);
        spriteBatch.Draw(pixel, new Rectangle(rect.X + (int)cameraManager.CameraPostion.X + rect.Width - thickness, rect.Y + (int)cameraManager.CameraPostion.Y, thickness, rect.Height), color);
    }



    private void EnemyDeath(EnemyZebi enemy)
    {
        enemy.rect = new Rectangle(enemy.rect.X, enemy.rect.Y, Globals.TILESIZE, Globals.TILESIZE);
        enemy.Dead = true;
        enemy.DeathCooldown.StartTimer();
        Debug.WriteLine($"Enemy {enemy.rect.X}, {enemy.rect.Y} mort, DeathCooldown démarré.");
    }

    private void HorizontalCollisions(GameTime gameTime, Dictionary<Vector2, int> tileCollisions, Dictionary<Vector2, int> tileForeGround)
    {
        foreach (var entity in sprites)
        {
            entity.Update(gameTime);

            entity.rect.X += (int)entity.velocity.X;
            intersections = getIntersectingTilesHorizontal(entity.rect);
            foreach (var rect in intersections)
            {
                if (tileCollisions.TryGetValue(new Vector2(rect.X, rect.Y), out int _val))
                {

                    // create temp rect to handle collisions (not necessary, you can optimize!)
                    Rectangle collision = new(
                        rect.X * Globals.TILESIZE,
                        rect.Y * Globals.TILESIZE,
                        Globals.TILESIZE,
                        Globals.TILESIZE
                    );

                    if (!entity.rect.Intersects(collision))
                    {
                        continue;
                    }



                    // ok je sais pas pk mais la c'est verticallement

                    if (entity is EnemyZebi enemy)
                    {
                        if (player.rect.Intersects(enemy.rect) && !enemy.Dead)
                        {
                            EnemyDeath(enemy);
                        }
                        foreach (var projectile in sprites.OfType<Projectiles>())
                        {
                            if (enemy.rect.Intersects(projectile.rect) && !enemy.Dead)
                            {
                                EnemyDeath(enemy);
                                Debug.WriteLine("Projectile hit enemy");

                                projectile.Summoned = false;
                                binList.Add(projectile);
                            }
                        }
                    }






                    // handle collisions based on the direction the player is moving
                    if (entity.velocity.X > 0.0f)
                    {
                        entity.rect.X = collision.Left - entity.rect.Width;
                        if (entity is Player)
                        {
                            player.Walled = true;
                        }
                        else
                        {
                            entity.Walled = true;
                        }
                    }
                    else if (entity.velocity.X < 0.0f)
                    {
                        entity.rect.X = collision.Right;
                        if (entity == player)
                        {
                            player.Walled = true;
                        }
                        else
                        {
                            entity.Walled = true;
                        }
                    }

                    //echelle sa mere
                    if (_val == 2)
                    {
                        entity.velocity.Y -= 10f;
                    }

                }
                else if (tileForeGround.TryGetValue(new Vector2(rect.X, rect.Y), out int _valFG))
                {
                    /*Debug.WriteLineIf(sprite == player, $"{_valFG}");
                    if (sprite == player && !player.Grounded)
                    {
                        this.player.Iced = false;
                        //Debug.WriteLine("zouzou");
                    }*/
                }
            }

        }
    }
    private void VerticalCollisions(Dictionary<Vector2, int> tileCollisions, Dictionary<Vector2, int> tileForeGround, Dictionary<Vector2, int> tileMg)
    {
        foreach (var entity in sprites)
        {
            if (entity is not Player)
            {
                entity.Grounded = false;
            }
            entity.rect.Y += (int)entity.velocity.Y;
            intersections = getIntersectingTilesVertical(entity.rect);
            foreach (var rect in intersections)
            {

                if (tileCollisions.TryGetValue(new Vector2(rect.X, rect.Y), out int _val))
                {

                    Rectangle collision = new Rectangle(rect.X * Globals.TILESIZE, rect.Y * Globals.TILESIZE, Globals.TILESIZE, Globals.TILESIZE);

                    if (!entity.rect.Intersects(collision))
                    {
                        continue;
                    }



                    if (entity is EnemyZebi enemy)
                    {
                        if (player.rect.Intersects(enemy.rect) && !enemy.Dead && Globals.NPS_Awarness)
                        {
                            if (!player.Invincibility)
                            {
                                player.Health -= 50;
                                player.velocity.X += 10 * enemy.Direction;
                                player.Invincibility = true;
                                player.StartInvincibility();
                            }
                        }

                        foreach (var projectile in sprites.OfType<Projectiles>())
                        {
                            if (Math.Abs(enemy.rect.X - projectile.rect.X) < 100 && Math.Abs(enemy.rect.Y - projectile.rect.Y) < 100)
                            {
                                if (enemy.rect.Intersects(projectile.rect) && !enemy.Dead)
                                {
                                    EnemyDeath(enemy);
                                }
                            }
                        }
                    }

                    if (entity is Items mushroom && player.rect.Intersects(mushroom.rect))
                    {
                        player.Health += 50;
                        mushroom.Summoned = false;
                    }

                    if (entity.velocity.Y > 0.0f)
                    {
                        entity.rect.Y = collision.Top - entity.rect.Height;
                        entity.velocity.Y = 1.0f;
                        entity.Grounded = true;
                        if (entity == player)
                        {
                            player.JumpCounter = 0;
                            player.FuckingRetardedBlockIHaveToUseABoolForDisShit = true;

                        }
                    }
                    else if (entity.velocity.Y < 0.0f)
                    {
                        entity.rect.Y = collision.Bottom;
                    }



                    switch (_val)
                    {
                        case -1:
                            if (entity == player)
                            {
                                this.player.Iced = false;
                                //Debug.WriteLine("case -1");
                            }
                            break;
                        case 0:

                            if (entity == player)
                            {
                                if (player.rect.Y > collision.Y)
                                {
                                    this.player.velocity.Y = 0;
                                }
                                this.player.Iced = false;
                                //Debug.WriteLine("case 1");
                            }
                            break;

                        case 3:
                            if (entity == player && player.Grounded)
                            {
                                if(player.rect.Y > collision.Y)
                                {
                                    this.player.velocity.Y = 0;
                                } 
                                this.player.Iced = true;
                                //Debug.WriteLine("case 3");
                            }
                            break;

                        case 4:
                            if (entity == player && player.rect.Y > collision.Y && player.FuckingRetardedBlockIHaveToUseABoolForDisShit)
                            {
                                this.player.Coins++;
                                this.player.FuckingRetardedBlockIHaveToUseABoolForDisShit = false;

                                this.player.velocity.Y = 0;

                                this.player.Iced = false;

                                // joueur toucher block, block transformer en autre block zebi
                                tileCollisions[new Vector2(rect.X, rect.Y)] = 5;

                                tileMg[new Vector2(rect.X, rect.Y)] = 1;

                                Items tempmushroom = new Items(Content.Load<Texture2D>("Mushroom"), new Rectangle(collision.X, collision.Y - 70, Globals.TILESIZE, Globals.TILESIZE), new Rectangle(0, 0, 8, 8));

                                usableItems.Add(tempmushroom);

                                tempmushroom.Summoned = true;

                                //Debug.WriteLine("zaza");
                            }
                            break;

                        case 5:
                            if (entity == player)
                            {
                                if (player.rect.Y > collision.Y)
                                {
                                    this.player.velocity.Y = 0;
                                }
                                //Debug.WriteLine("case 5");
                                this.player.Iced = false;

                            }

                            break;


                        default:
                            if (entity == player)
                            {
                                if (player.rect.Y > collision.Y)
                                {
                                    this.player.velocity.Y = 0;
                                }
                                //Debug.WriteLine("case 6");
                                this.player.Iced = false;
                            }
                            break;
                    }


                }
            }



        }
    }
    

    private void ListManager()
    {
        if (usableItems.Any())
        {
            foreach (var item in usableItems)
            {
                sprites.Add(item);
            }
            usableItems.Clear();
        }

        foreach (var sprite in sprites)
        {
                if (sprite is not Player && sprite.rect.Y > 9000)
                {
                    binList.Add(sprite);
                }
        }
        foreach (var shit in binList)
        {
                sprites.Remove(shit);
        }
        binList.Clear();
        

        foreach (var projectile in sprites.OfType<Projectiles>())
        {
            if (projectile.Walled)
            {
                binList.Add(projectile);
            }
        }
    }


    private void MapDraw(float drawDistance, Dictionary<Vector2, int> tiles, Texture2D texture)
    {
        if (tiles != null)
        {
            foreach (var item in tiles)
            {
                Vector2 tilePosition = item.Key * Globals.TILESIZE;
                float distance = Vector2.Distance(tilePosition, player.rect.Location.ToVector2());


                if (distance < drawDistance && !cameraManager.IsCinemating)
                {
                    Rectangle drect = new(
                        (int)item.Key.X * Globals.TILESIZE + (int)cameraManager.CameraPostion.X,
                        (int)item.Key.Y * Globals.TILESIZE + (int)cameraManager.CameraPostion.Y,
                        Globals.TILESIZE,
                        Globals.TILESIZE
                    );

                    int x = item.Value % num_tiles_per_row;
                    int y = item.Value / num_tiles_per_row;

                    Rectangle src = new(
                        x * pixel_tilesize,
                        y * pixel_tilesize,
                        pixel_tilesize,
                        pixel_tilesize
                    );

                    Globals.SpriteBatch.Draw(texture, drect, src, Color.White);
                }
                else
                {
                    Rectangle drect = new(
                (int)item.Key.X * Globals.TILESIZE + (int)cameraManager.CameraPostion.X,
                (int)item.Key.Y * Globals.TILESIZE + (int)cameraManager.CameraPostion.Y,
                Globals.TILESIZE,
                Globals.TILESIZE
            );

                    // get the src rect (the part of the image drawn) from the value
                    int x = item.Value % num_tiles_per_row;
                    int y = item.Value / num_tiles_per_row;

                    Rectangle src = new(
                        x * pixel_tilesize,
                        y * pixel_tilesize,
                        pixel_tilesize,
                        pixel_tilesize
                    );

                    Globals.SpriteBatch.Draw(texture, drect, src, Color.White);
                }
            }
        }
    }

    private void SpritesDraw(float drawDistance)
    {

        foreach (var sprite in sprites)
        {
            float distance = Vector2.Distance(sprite.rect.Location.ToVector2(), player.rect.Location.ToVector2());
            if (distance < drawDistance)
            {
                sprite.Draw(Globals.SpriteBatch, cameraManager.CameraPostion);
                DrawRectHollow(Globals.SpriteBatch, sprite.rect, Color.Green, 4);
            }

        }

        foreach (var box in enemyBoxes.Values)
        {
            if (Keyboard.GetState().IsKeyDown(Keys.B))  
            {
                float distance = Vector2.Distance(box.rect.Location.ToVector2(), player.rect.Location.ToVector2());
                if (distance < drawDistance)
                {
                    box.Draw(cameraManager.CameraPostion);
                }
            }
        }

        if (player.Invincibility)
        {
            player.Draw(Globals.SpriteBatch, cameraManager.CameraPostion);
        }
    }
    private void StompMecanism(GameTime gameTime)
    {
        foreach (var kvp in enemyBoxes)
        {
            EnemyZebi enemy = kvp.Key;
            TriggerBox stompBox = kvp.Value;

            if (player.rect.Intersects(stompBox.rect) && !player.Invincibility)
            {
                player.velocity.Y += -1200 * Globals.DeltaTime;
                EnemyDeath(enemy);
                break;
            }
            if (stompBox.rect.Y > 8500)
            {
                enemyBoxes.Remove(enemy);
            }
        }

        foreach (var sprite in sprites)
        {
            if (sprite is EnemyZebi enemy)
            {
                enemy.DeathCooldown.Update(gameTime);

                if (!enemyBoxes.ContainsKey(enemy))
                {
                    enemyBoxes[enemy] = new TriggerBox(pixel, new Rectangle(enemy.rect.X, enemy.rect.Y - 20, Globals.TILESIZE, Globals.TILESIZE));
                }

                enemyBoxes[enemy].rect = new Rectangle(enemy.rect.X + 7, enemy.rect.Y - 20, 50, 70);

                if (enemy.Dead)
                {
                    if (enemyBoxes.ContainsKey(enemy))
                    {
                        enemyBoxes.Remove(enemy);
                    }
                    if (!enemy.DeathCooldown.Active)
                    {
                        binList.Add(sprite);
                        Debug.WriteLine($"Suppression de l'ennemi à la position {enemy.rect.X}, {enemy.rect.Y}");
                    }
                }
            }
            else if (sprite is Items mushroom && !mushroom.Summoned)
            {
                binList.Add(mushroom);
            }
        }
    }
}

